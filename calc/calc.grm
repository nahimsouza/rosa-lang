(* Sample interactive calculator for ML-Yacc *)

datatype value =
  Integer of int
  | Real of real

val lookupTable : (string, value) HashTable.hash_table =
    HashTable.mkTable (HashString.hashString, op=) (42, Fail "not found")

fun lookup id : (value) = HashTable.lookup lookupTable id

fun save id exp = HashTable.insert lookupTable (id, exp)

fun soma exp1 exp2 =
  case (exp1, exp2) of (Integer exp1, Integer exp2) => Integer ((Int.toInt exp1) + (Int.toInt exp2))
                    | (Real exp1, Real exp2) => Real ((Real.toLarge exp1) + (Real.toLarge exp2))

fun valueToString exp =
  case exp of Integer x => Int.toString x
            | Real x => Real.toString x

%%

%eop EOF SEMI

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos int

%left SUB PLUS
%left TIMES DIV
%right CARAT

%term ID of string | INT of int | REAL of real | PLUS | TIMES | PRINT |
      SEMI | EOF | CARAT | DIV | SUB | EQUAL
%nonterm EXP of value | ASSIGN of unit | START of string option

%name Calc

%subst PRINT for ID
%prefer PLUS TIMES DIV SUB
%keyword PRINT SEMI

%noshift EOF
%value ID ("bogus")
%verbose
%%

(* the parser returns the value associated with the expression *)

  START : PRINT EXP (print (valueToString EXP);
                     print "\n";
                     SOME (valueToString EXP))
        | EXP (SOME (valueToString EXP))
        | ASSIGN (NONE)
        | (NONE)
  ASSIGN : ID EQUAL EXP (save ID EXP)
  EXP : INT             (Integer INT)
      | REAL            (Real REAL)
      | ID              (lookup ID)
      (* | ID EQUAL EXP    (save ID EXP) *)
      | EXP PLUS EXP    (soma EXP1 EXP2)
      (* | EXP TIMES EXP   (EXP1*EXP2)
      | EXP DIV EXP     (EXP1 div EXP2)
      | EXP SUB EXP     (EXP1-EXP2)
      | EXP CARAT EXP   (let fun e (m,0) = 1
                                | e (m,l) = m*e(m,l-1)
                         in e (EXP1,EXP2)
                         end) *)
