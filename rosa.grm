(* Rosa programming language interpreter - Grammar*)

(* ============================ User declarations ============================  *)


(* RosaType represent the types used in ROSA lang *)
datatype RosaType =
  Integer of int
  | Real of real
  | Boolean of bool
  | String of string
  | RSequence of string
  | DSequence of string
  | PSequence of string
  | Quality of string
  | Fasta of string * string
  | Fastq of string * string * string

(* lookupTable is a HashTable used to store identifiers and their values *)
val lookupTable : (string, RosaType) HashTable.hash_table =
    HashTable.mkTable (HashString.hashString, op=) (42, Fail "not found")

(* get the value of the identifier *)
fun lookup id : (RosaType) = HashTable.lookup lookupTable id

(* checks if the type of exp matches with the given type name *)
fun typeMatch exp typename =
  case (exp, typename) of
    ((Integer _, "Integer") | (Real _, "Real") | (Boolean _, "Boolean") | (String _, "String")
      | (Quality _, "Quality") | (RSequence _, "Sequence") | (DSequence _, "Sequence")
      | (PSequence _, "Sequence")) => true
    | _ => false

(* save the value of the identifier and returns the value of 'exp' *)
fun save id exp typename =
  if typeMatch exp typename
  then
    let
      val _ = HashTable.insert lookupTable (id, exp)
    in
      exp
    end
  else
    raise Fail "Type Error: Type mismatch in declaration"

(* Basic expession evaluation functions *)

(* Sequence concat helper functions *)
fun getSequenceContent s = String.extract(s, 2, NONE)

fun getSequencePrefix s = String.substring(s, 0, 2)

fun concatSequenceContents(s1, s2) =
  let
    val prefix = getSequencePrefix s1
  in
    concat [prefix, (getSequenceContent s1), (getSequenceContent s2)]
  end

fun plus exp1 exp2 =
  case (exp1, exp2) of (Integer exp1, Integer exp2) => Integer ((Int.toInt exp1) + (Int.toInt exp2))
                    | (Real exp1, Real exp2) => Real ((Real.toLarge exp1) + (Real.toLarge exp2))
                    | (Integer exp1, Real exp2) => Real ((Real.fromInt exp1) + (Real.toLarge exp2))
                    | (Real exp1, Integer exp2) => Real ((Real.toLarge exp1) + (Real.fromInt exp2))
                    | (RSequence exp1, RSequence exp2) => RSequence (concatSequenceContents(exp1, exp2))
                    | (DSequence exp1, DSequence exp2) => DSequence (concatSequenceContents(exp1, exp2))
                    | (PSequence exp1, PSequence exp2) => PSequence (concatSequenceContents(exp1, exp2))
                    | _ => raise Fail "Type Error: Operation not supported"

fun times exp1 exp2 =
  case (exp1, exp2) of (Integer exp1, Integer exp2) => Integer ((Int.toInt exp1) * (Int.toInt exp2))
                    | (Real exp1, Real exp2) => Real ((Real.toLarge exp1) * (Real.toLarge exp2))
                    | (Integer exp1, Real exp2) => Real ((Real.fromInt exp1) * (Real.toLarge exp2))
                    | (Real exp1, Integer exp2) => Real ((Real.toLarge exp1) * (Real.fromInt exp2))
                    | _ => raise Fail "Type Error: Operation not supported"

fun sub exp1 exp2 =
  case (exp1, exp2) of (Integer exp1, Integer exp2) => Integer ((Int.toInt exp1) - (Int.toInt exp2))
                    | (Real exp1, Real exp2) => Real ((Real.toLarge exp1) - (Real.toLarge exp2))
                    | (Integer exp1, Real exp2) => Real ((Real.fromInt exp1) - (Real.toLarge exp2))
                    | (Real exp1, Integer exp2) => Real ((Real.toLarge exp1) - (Real.fromInt exp2))
                    | _ => raise Fail "Type Error: Operation not supported"

fun divide exp1 exp2 =
  case (exp1, exp2) of (Integer exp1, Integer exp2) => Integer ((Int.toInt exp1) div (Int.toInt exp2))
                    | (Real exp1, Real exp2) => Real ((Real.toLarge exp1) / (Real.toLarge exp2))
                    | (Integer exp1, Real exp2) => Real ((Real.fromInt exp1) / (Real.toLarge exp2))
                    | (Real exp1, Integer exp2) => Real ((Real.toLarge exp1) / (Real.fromInt exp2))
                    | _ => raise Fail "Type Error: Operation not supported"

fun valueToString exp =
  case exp of Integer x => Int.toString x
            | Real x => Real.toString x
            | Boolean x => Bool.toString x
            | String x => x
            | Quality x => x
            | RSequence x => x
            | DSequence x => x
            | PSequence x => x
            | Fasta x => #1(x) ^ "\n" ^ #2(x)
            | _ => raise Fail "Type Error: Operation not supported"


%%

(* ============================ ML-Yacc declarations ============================  *)

%eop EOF SEMI

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos int

%left SUB PLUS
%left TIMES DIV
%right CARAT

(* Symbols definition - terminal and non-terminals *)
%term ID of string | INT of int | REAL of real | PLUS | TIMES | PRINT |
      SEMI | EOF | CARAT | DIV | SUB | EQUAL | BOOLEAN of bool |
      INS | DEL | POINT | TRANSCRIBE | TRANSLATE | COMPLEMENT | MOTIF |
      QCTRL | TRIM | TOFASTA | READ | READFA | READFQ | WRITE |
      WRITEFA | WRITEFQ | INPUT | TYPE of string | NOT | AND | OR | DOUBLEEQUAL |
      LPAREN | RPAREN | STRING of string |
      RSEQUENCE of string | DSEQUENCE of string | PSEQUENCE of string |
      QUALITY of string | FASTA of string * string
%nonterm EXP of RosaType | START of string option

(* Language name used by ML-Lex to generate SML code *)
%name Rosa

%subst PRINT for ID
%prefer PLUS TIMES DIV SUB
%keyword PRINT SEMI

%noshift EOF
%value ID ("bogus")
%verbose

%%

(* ============================ ML-Yacc Rules ============================  *)

(* the parser returns the value associated with the expression *)

  START : PRINT EXP (print (valueToString EXP);
                     print "\n";
                     SOME (valueToString EXP))
        | EXP (SOME (valueToString EXP))
        | (NONE)
  EXP : INT             (Integer INT)
      | REAL            (Real REAL)
      | BOOLEAN         (Boolean BOOLEAN)
      | STRING          (String STRING)
      | RSEQUENCE       (RSequence RSEQUENCE)
      | DSEQUENCE       (DSequence DSEQUENCE)
      | PSEQUENCE       (PSequence PSEQUENCE)
      | QUALITY         (Quality QUALITY)
      | FASTA           (Fasta FASTA)
      | ID              (lookup ID)
      | TYPE ID EQUAL EXP    (save ID EXP TYPE)
      | EXP PLUS EXP    (plus EXP1 EXP2)
      | EXP TIMES EXP   (times EXP1 EXP2)
      | EXP DIV EXP     (divide EXP1 EXP2)
      | EXP SUB EXP     (sub EXP1 EXP2)
      (* | EXP CARAT EXP   (let fun e (m,0) = 1
                                | e (m,l) = m*e(m,l-1)
                         in e (EXP1,EXP2)
                         end) *)
